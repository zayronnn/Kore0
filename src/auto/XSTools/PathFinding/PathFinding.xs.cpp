/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.30 from the
 * contents of PathFinding.xs. Do not edit this file, edit PathFinding.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
#include <stdlib.h>
#include <time.h>
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "algorithm.h"
typedef CalcPath_session * PathFinding;

#line 20 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 164 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"

XS_EUPXS(XS_PathFinding_create); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PathFinding_create)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	PathFinding	RETVAL;
#line 16 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		RETVAL = CalcPath_new ();

#line 177 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "PathFinding",
	    (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PathFinding__reset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PathFinding__reset)
{
    dVAR; dXSARGS;
    if (items != 18)
       croak_xs_usage(cv,  "session, weight_map, avoidWalls, customWeights, secondWeightMap, randomFactor, useManhattan, width, height, startx, starty, destx, desty, time_max, min_x, max_x, min_y, max_y");
    {
	PathFinding	session;
	SV *	weight_map = ST(1)
;
	SV *	avoidWalls = ST(2)
;
	SV *	customWeights = ST(3)
;
	SV *	secondWeightMap = ST(4)
;
	SV *	randomFactor = ST(5)
;
	SV *	useManhattan = ST(6)
;
	SV *	width = ST(7)
;
	SV *	height = ST(8)
;
	SV *	startx = ST(9)
;
	SV *	starty = ST(10)
;
	SV *	destx = ST(11)
;
	SV *	desty = ST(12)
;
	SV *	time_max = ST(13)
;
	SV *	min_x = ST(14)
;
	SV *	max_x = ST(15)
;
	SV *	min_y = ST(16)
;
	SV *	max_y = ST(17)
;
#line 44 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		char *weight_map_data = NULL;

#line 235 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"

	if (sv_derived_from(ST(0), "PathFinding")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
	session = (PathFinding) tmp;
	}
	else
		croak("session is not of type PathFinding")
;
#line 48 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		/* If the object was already initiated, clean map memory */
		if (session->initialized) {
			free_currentMap(session);
			session->initialized = 0;
		}

		/* If the path has already been calculated on this object, clean openlist memory */
		if (session->run) {
			free_openList(session);
			session->run = 0;
		}

		/* Check for any missing arguments */
		if (!session || !weight_map || !avoidWalls  || !customWeights || !secondWeightMap || !randomFactor || !useManhattan || !width || !height || !startx || !starty || !destx || !desty || !time_max || !min_x || !max_x || !min_y || !max_y) {
			printf("[pathfinding reset error] missing argument\n");
			XSRETURN_NO;
		}

		/* Check for any bad arguments */
		if (SvROK(avoidWalls) || SvTYPE(avoidWalls) >= SVt_PVAV || !SvOK(avoidWalls)) {
			printf("[pathfinding reset error] bad avoidWalls argument\n");
			XSRETURN_NO;
		}

		if (SvROK(customWeights) || SvTYPE(customWeights) >= SVt_PVAV || !SvOK(customWeights)) {
			printf("[pathfinding reset error] bad customWeights argument\n");
			XSRETURN_NO;
		}

		if (SvROK(randomFactor) || SvTYPE(randomFactor) >= SVt_PVAV || !SvOK(randomFactor)) {
			printf("[pathfinding reset error] bad randomFactor argument\n");
			XSRETURN_NO;
		}

		if (SvROK(useManhattan) || SvTYPE(useManhattan) >= SVt_PVAV || !SvOK(useManhattan)) {
			printf("[pathfinding reset error] bad useManhattan argument\n");
			XSRETURN_NO;
		}

		if (SvROK(width) || SvTYPE(width) >= SVt_PVAV || !SvOK(width)) {
			printf("[pathfinding reset error] bad width argument\n");
			XSRETURN_NO;
		}

		if (SvROK(height) || SvTYPE(height) >= SVt_PVAV || !SvOK(height)) {
			printf("[pathfinding reset error] bad height argument\n");
			XSRETURN_NO;
		}

		if (SvROK(startx) || SvTYPE(startx) >= SVt_PVAV || !SvOK(startx)) {
			printf("[pathfinding reset error] bad startx argument\n");
			XSRETURN_NO;
		}

		if (SvROK(starty) || SvTYPE(starty) >= SVt_PVAV || !SvOK(starty)) {
			printf("[pathfinding reset error] bad starty argument\n");
			XSRETURN_NO;
		}

		if (SvROK(destx) || SvTYPE(destx) >= SVt_PVAV || !SvOK(destx)) {
			printf("[pathfinding reset error] bad destx argument\n");
			XSRETURN_NO;
		}

		if (SvROK(desty) || SvTYPE(desty) >= SVt_PVAV || !SvOK(desty)) {
			printf("[pathfinding reset error] bad desty argument\n");
			XSRETURN_NO;
		}

		if (SvROK(time_max) || SvTYPE(time_max) >= SVt_PVAV || !SvOK(time_max)) {
			printf("[pathfinding reset error] bad time_max argument\n");
			XSRETURN_NO;
		}

		if (!SvROK(weight_map) || !SvOK(weight_map)) {
			printf("[pathfinding reset error] bad weight_map argument\n");
			XSRETURN_NO;
		}

		if (SvROK(min_x) || SvTYPE(min_x) >= SVt_PVAV || !SvOK(min_x)) {
			printf("[pathfinding reset error] bad min_x argument\n");
			XSRETURN_NO;
		}

		if (SvROK(max_x) || SvTYPE(max_x) >= SVt_PVAV || !SvOK(max_x)) {
			printf("[pathfinding reset error] bad max_x argument\n");
			XSRETURN_NO;
		}

		if (SvROK(min_y) || SvTYPE(min_y) >= SVt_PVAV || !SvOK(min_y)) {
			printf("[pathfinding reset error] bad min_y argument\n");
			XSRETURN_NO;
		}

		if (SvROK(max_y) || SvTYPE(max_y) >= SVt_PVAV || !SvOK(max_y)) {
			printf("[pathfinding reset error] bad max_y argument\n");
			XSRETURN_NO;
		}

		/* Get the weight_map data */
		weight_map_data = (char *) SvPV_nolen (SvRV (weight_map));
		session->map_base_weight = weight_map_data;

		session->width = (int) SvUV (width);
		session->height = (int) SvUV (height);

		session->startX = (int) SvUV (startx);
		session->startY = (int) SvUV (starty);
		session->endX = (int) SvUV (destx);
		session->endY = (int) SvUV (desty);

		session->min_x = (int) SvUV (min_x);
		session->max_x = (int) SvUV (max_x);
		session->min_y = (int) SvUV (min_y);
		session->max_y = (int) SvUV (max_y);

		srand(time(0));
		session->randomFactor = (unsigned int) SvUV (randomFactor);
		session->useManhattan = (unsigned short) SvUV (useManhattan);

		// Min and max check
		if (session->min_x >= session->width || session->min_y >= session->height || session->min_x < 0 || session->min_y < 0) {
			printf("[pathfinding reset error] Minimum coordinates %d %d are out of the map (size: %d x %d).\n", session->min_x, session->min_y, session->width, session->height);
			XSRETURN_NO;
		}

		if (session->max_x >= session->width || session->max_y >= session->height || session->max_x < 0 || session->max_y < 0) {
			printf("[pathfinding reset error] Maximum coordinates %d %d are out of the map (size: %d x %d).\n", session->max_x, session->max_y, session->width, session->height);
			XSRETURN_NO;
		}

		// Start check
		if (session->startX >= session->width || session->startY >= session->height || session->startX < 0 || session->startY < 0) {
			printf("[pathfinding reset error] Start coordinate %d %d is out of the map (size: %d x %d).\n", session->startX, session->startY, session->width, session->height);
			XSRETURN_NO;
		}

		if (session->map_base_weight[((session->startY * session->width) + session->startX)] == -1) {
			printf("[pathfinding reset error] Start coordinate %d %d is not a walkable cell.\n", session->startX, session->startY);
			XSRETURN_NO;
		}

		if (session->startX > session->max_x || session->startY > session->max_y || session->startX < session->min_x || session->startY < session->min_y) {
			printf("[pathfinding reset error] Start coordinate %d %d is out of the minimum and maximum coordinates (size: %d .. %d x %d .. %d).\n", session->startX, session->startY, session->min_x, session->max_x, session->min_y, session->max_y);
			XSRETURN_NO;
		}

		// End check
		if (session->endX >= session->width   || session->endY >= session->height   || session->endX < 0   || session->endY < 0) {
			printf("[pathfinding reset error] End coordinate %d %d is out of the map (size: %d x %d).\n", session->endX, session->endY, session->width, session->height);
			XSRETURN_NO;
		}

		if (session->map_base_weight[((session->endY * session->width) + session->endX)] == -1) {
			printf("[pathfinding reset error] End coordinate %d %d is not a walkable cell.\n", session->endX, session->endY);
			XSRETURN_NO;
		}

		if (session->endX > session->max_x || session->endY > session->max_y || session->endX < session->min_x || session->endY < session->min_y) {
			printf("[pathfinding reset error] End coordinate %d %d is out of the minimum and maximum coordinates (size: %d .. %d x %d .. %d).\n", session->endX, session->endY, session->min_x, session->max_x, session->min_y, session->max_y);
			XSRETURN_NO;
		}

		session->avoidWalls = (unsigned short) SvUV (avoidWalls);
		session->customWeights = (unsigned short) SvUV (customWeights);
		session->time_max = (unsigned int) SvUV (time_max);

		CalcPath_init(session);

		if (session->customWeights) {
			/* secondWeightMap should be a reference to an array */
			if (!SvROK(secondWeightMap)) {
				printf("[pathfinding reset error] secondWeightMap is not a reference\n");
				XSRETURN_NO;
			}

			if (SvTYPE(SvRV(secondWeightMap)) != SVt_PVAV) {
				printf("[pathfinding reset error] secondWeightMap is not an array reference\n");
				XSRETURN_NO;
			}

			if (!SvOK(secondWeightMap)) {
				printf("[pathfinding reset error] secondWeightMap is not defined\n");
				XSRETURN_NO;
			}

			AV *deref_secondWeightMap;
			I32 array_len;

			deref_secondWeightMap = (AV *) SvRV (secondWeightMap);
			array_len = av_len (deref_secondWeightMap);

			if (array_len == -1) {
				printf("[pathfinding reset error] secondWeightMap has no members\n");
				XSRETURN_NO;
			}

			SV **fetched;
			HV *hash;

			SV **ref_x;
			SV **ref_y;
			SV **ref_weight;

			IV x;
			IV y;

			I32 index;

			for (index = 0; index <= array_len; index++) {
				fetched = av_fetch (deref_secondWeightMap, index, 0);

				if (!SvROK(*fetched)) {
					printf("[pathfinding reset error] [secondWeightMap] member of array is not a reference\n");
					XSRETURN_NO;
				}

				if (SvTYPE(SvRV(*fetched)) != SVt_PVHV) {
					printf("[pathfinding reset error] [secondWeightMap] member of array is not a reference to a hash\n");
					XSRETURN_NO;
				}

				if (!SvOK(*fetched)) {
					printf("[pathfinding reset error] [secondWeightMap] member of array is not defined\n");
					XSRETURN_NO;
				}

				hash = (HV*) SvRV(*fetched);

				if (!hv_exists(hash, "x", 1)) {
					printf("[pathfinding reset error] [secondWeightMap] member of array does not contain the key 'x'\n");
					XSRETURN_NO;
				}

				ref_x = hv_fetch(hash, "x", 1, 0);

				if (SvROK(*ref_x)) {
					printf("[pathfinding reset error] [secondWeightMap] member of array 'x' key is a reference\n");
					XSRETURN_NO;
				}

				if (SvTYPE(*ref_x) >= SVt_PVAV) {
					printf("[pathfinding reset error] [secondWeightMap] member of array 'x' key is not a scalar\n");
					XSRETURN_NO;
				}

				if (!SvOK(*ref_x)) {
					printf("[pathfinding reset error] [secondWeightMap] member of array 'x' key is not defined\n");
					XSRETURN_NO;
				}

				x = SvIV(*ref_x);

				if (!hv_exists(hash, "y", 1)) {
					printf("[pathfinding reset error] [secondWeightMap] member of array does not contain the key 'y'\n");
					XSRETURN_NO;
				}

				ref_y = hv_fetch(hash, "y", 1, 0);

				if (SvROK(*ref_y)) {
					printf("[pathfinding reset error] [secondWeightMap] member of array 'y' key is a reference\n");
					XSRETURN_NO;
				}

				if (SvTYPE(*ref_y) >= SVt_PVAV) {
					printf("[pathfinding reset error] [secondWeightMap] member of array 'y' key is not a scalar\n");
					XSRETURN_NO;
				}

				if (!SvOK(*ref_y)) {
					printf("[pathfinding reset error] [secondWeightMap] member of array 'y' key is not defined\n");
					XSRETURN_NO;
				}

				y = SvIV(*ref_y);

				if (!hv_exists(hash, "weight", 6)) {
					printf("[pathfinding reset error] [secondWeightMap] member of array does not contain the key 'weight'\n");
					XSRETURN_NO;
				}

				ref_weight = hv_fetch(hash, "weight", 6, 0);

				if (SvROK(*ref_weight)) {
					printf("[pathfinding reset error] [secondWeightMap] member of array 'weight' key is a reference\n");
					XSRETURN_NO;
				}

				if (SvTYPE(*ref_weight) >= SVt_PVAV) {
					printf("[pathfinding reset error] [secondWeightMap] member of array 'weight' key is not a scalar\n");
					XSRETURN_NO;
				}

				if (!SvOK(*ref_weight)) {
					printf("[pathfinding reset error] [secondWeightMap] member of array 'weight' key is not defined\n");
					XSRETURN_NO;
				}

				unsigned int weight = SvIV(*ref_weight);

				long current = (y * session->width) + x;

				session->second_weight_map[current] = weight;
			}
		} else {
			if (SvOK(secondWeightMap)) {
				printf("[pathfinding reset error] secondWeightMap is defined while customWeights is 0\n");
				XSRETURN_NO;
			}
		}
#line 556 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PathFinding_run); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PathFinding_run)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "session, solution_array");
    {
	PathFinding	session;
	SV *	solution_array = ST(1)
;
#line 365 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		int status;
#line 574 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "PathFinding")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
	session = (PathFinding) tmp;
	}
	else
		croak("session is not of type PathFinding")
;
#line 368 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		/* Check for any missing arguments */
		if (!session || !solution_array) {
			printf("[pathfinding run error] missing argument\n");
			XSRETURN_NO;
		}

		/* solution_array should be a reference to an array */
		if (!SvROK(solution_array)) {
			printf("[pathfinding run error] solution_array is not a reference\n");
			XSRETURN_NO;
		}

		if (SvTYPE(SvRV(solution_array)) != SVt_PVAV) {
			printf("[pathfinding run error] solution_array is not an array reference\n");
			XSRETURN_NO;
		}

		if (!SvOK(solution_array)) {
			printf("[pathfinding run error] solution_array is not defined\n");
			XSRETURN_NO;
		}

		status = CalcPath_pathStep (session);

		if (status < 0) {
			RETVAL = status;
		} else {
			AV *array;
			long size;

			size = (session->solution_size + 1);
 			array = (AV *) SvRV (solution_array);
			av_clear (array);
			av_extend (array, size);

			Node currentNode = session->currentMap[(session->endY * session->width) + session->endX];
			long current = session->solution_size;

			while (1)
			{
				HV * rh = (HV *)sv_2mortal((SV *)newHV());

				hv_store(rh, "x", 1, newSViv(currentNode.x), 0);

				hv_store(rh, "y", 1, newSViv(currentNode.y), 0);

				av_store(array, current, newRV((SV *)rh));

				if (current == 0) {
					break;
				} else {
					currentNode = session->currentMap[currentNode.predecessor];
					current--;
				}
			}

			RETVAL = size;
		}
#line 644 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PathFinding_runcount); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PathFinding_runcount)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "session");
    {
	PathFinding	session;
#line 433 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		int status;
#line 661 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "PathFinding")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
	session = (PathFinding) tmp;
	}
	else
		croak("session is not of type PathFinding")
;
#line 436 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		status = CalcPath_pathStep (session);

		if (status < 0) {
			RETVAL = status;
		} else {
			RETVAL = (long) session->solution_size;
		}
#line 680 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PathFinding_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PathFinding_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "session");
    {
	PathFinding	session;
#line 450 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		session = (PathFinding) 0; /* shut up compiler warning */
#line 697 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"

	if (sv_derived_from(ST(0), "PathFinding")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
	session = (PathFinding) tmp;
	}
	else
		croak("session is not of type PathFinding")
;
#line 452 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		CalcPath_destroy (session);
#line 708 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PathFinding_checkTile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PathFinding_checkTile)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "ix, iy, itile, iwidth, iheight, rawMap");
    {
	SV *	ix = ST(0)
;
	SV *	iy = ST(1)
;
	SV *	itile = ST(2)
;
	SV *	iwidth = ST(3)
;
	SV *	iheight = ST(4)
;
	SV *	rawMap = ST(5)
;
	int	RETVAL;
	dXSTARG;
#line 464 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		int x = (int) SvUV (ix);
		int y = (int) SvUV (iy);
		int tile = (int) SvUV (itile);
		int width = (int) SvUV (iwidth);
		int height = (int) SvUV (iheight);

		char * rawMap_data = (char *) SvPVbyte_nolen (SvRV (rawMap));

		RETVAL = checkTile_inner(x, y, tile, width, height, rawMap_data);

#line 746 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PathFinding_checkLOS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PathFinding_checkLOS)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "istart_x, istart_y, iend_x, iend_y, itile, iwidth, iheight, rawMap");
    {
	SV *	istart_x = ST(0)
;
	SV *	istart_y = ST(1)
;
	SV *	iend_x = ST(2)
;
	SV *	iend_y = ST(3)
;
	SV *	itile = ST(4)
;
	SV *	iwidth = ST(5)
;
	SV *	iheight = ST(6)
;
	SV *	rawMap = ST(7)
;
	int	RETVAL;
	dXSTARG;
#line 489 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		int start_x = (int) SvUV (istart_x);
		int start_y = (int) SvUV (istart_y);
		int end_x = (int) SvUV (iend_x);
		int end_y = (int) SvUV (iend_y);
		int tile = (int) SvUV (itile);
		int width = (int) SvUV (iwidth);
		int height = (int) SvUV (iheight);

		char * rawMap_data = (char *) SvPVbyte_nolen (SvRV (rawMap));

		RETVAL = checkLOS_inner(start_x, start_y, end_x, end_y, tile, width, height, rawMap_data);

#line 791 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PathFinding_canAttack); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PathFinding_canAttack)
{
    dVAR; dXSARGS;
    if (items != 10)
       croak_xs_usage(cv,  "istart_x, istart_y, iend_x, iend_y, itile, iwidth, iheight, irange, iclientSight, rawMap");
    {
	SV *	istart_x = ST(0)
;
	SV *	istart_y = ST(1)
;
	SV *	iend_x = ST(2)
;
	SV *	iend_y = ST(3)
;
	SV *	itile = ST(4)
;
	SV *	iwidth = ST(5)
;
	SV *	iheight = ST(6)
;
	SV *	irange = ST(7)
;
	SV *	iclientSight = ST(8)
;
	SV *	rawMap = ST(9)
;
	int	RETVAL;
	dXSTARG;
#line 518 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		int start_x = (int) SvUV (istart_x);
		int start_y = (int) SvUV (istart_y);
		int end_x = (int) SvUV (iend_x);
		int end_y = (int) SvUV (iend_y);
		int tile = (int) SvUV (itile);
		int width = (int) SvUV (iwidth);
		int height = (int) SvUV (iheight);
		int range = (int) SvUV (irange);
		int clientSight = (int) SvUV (iclientSight);

		char * rawMap_data = (char *) SvPVbyte_nolen (SvRV (rawMap));

		RETVAL = canAttack_inner(start_x, start_y, end_x, end_y, tile, width, height, range, clientSight, rawMap_data);

#line 842 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PathFinding_calcRectArea); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PathFinding_calcRectArea)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "i_x, i_y, iradius, itile, iwidth, iheight, rawMap, solution_array");
    {
	SV *	i_x = ST(0)
;
	SV *	i_y = ST(1)
;
	SV *	iradius = ST(2)
;
	SV *	itile = ST(3)
;
	SV *	iwidth = ST(4)
;
	SV *	iheight = ST(5)
;
	SV *	rawMap = ST(6)
;
	SV *	solution_array = ST(7)
;
#line 547 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		int x = (int) SvUV (i_x);
		int y = (int) SvUV (i_y);
		int radius = (int) SvUV (iradius);
		int tile = (int) SvUV (itile);
		int width = (int) SvUV (iwidth);
		int height = (int) SvUV (iheight);

		char * rawMap_data = (char *) SvPVbyte_nolen (SvRV (rawMap));

		int * limits = getSquareEdgesFromCoord_inner(x, y, radius, width, height);
		int min_x = limits[0];
		int min_y = limits[1];
		int max_x = limits[2];
		int max_y = limits[3];

		AV *array;
 		array = (AV *) SvRV (solution_array);
		av_clear (array);

		int offset;

		int value;

		int size;

		x = min_x;
		y = min_y;
		offset = (y * width) + x;
		size = 0;

		while (x < max_x) {
			value = rawMap_data[offset];
			if (value & tile) {
				av_extend (array, (size+1));
				HV * rh = (HV *)sv_2mortal((SV *)newHV());

				hv_store(rh, "x", 1, newSViv(x), 0);
				hv_store(rh, "y", 1, newSViv(y), 0);

				av_store(array, size, newRV((SV *)rh));
				size++;
			}
			offset++;
			x++;
		}

		while (y < max_y) {
			value = rawMap_data[offset];
			if (value & tile) {
				av_extend (array, (size+1));
				HV * rh = (HV *)sv_2mortal((SV *)newHV());

				hv_store(rh, "x", 1, newSViv(x), 0);
				hv_store(rh, "y", 1, newSViv(y), 0);

				av_store(array, size, newRV((SV *)rh));
				size++;
			}
			offset += width;
			y++;
		}

		while (x > min_x) {
			value = rawMap_data[offset];
			if (value & tile) {
				av_extend (array, (size+1));
				HV * rh = (HV *)sv_2mortal((SV *)newHV());

				hv_store(rh, "x", 1, newSViv(x), 0);
				hv_store(rh, "y", 1, newSViv(y), 0);

				av_store(array, size, newRV((SV *)rh));
				size++;
			}
			offset--;
			x--;
		}

		while (y > min_y) {
			value = rawMap_data[offset];
			if (value & tile) {
				av_extend (array, (size+1));
				HV * rh = (HV *)sv_2mortal((SV *)newHV());

				hv_store(rh, "x", 1, newSViv(x), 0);
				hv_store(rh, "y", 1, newSViv(y), 0);

				av_store(array, size, newRV((SV *)rh));
				size++;
			}
			offset -= width;
			y--;
		}
#line 966 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PathFinding_checkPathFree); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PathFinding_checkPathFree)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "istart_x, istart_y, iend_x, iend_y, itile, iwidth, iheight, rawMap");
    {
	SV *	istart_x = ST(0)
;
	SV *	istart_y = ST(1)
;
	SV *	iend_x = ST(2)
;
	SV *	iend_y = ST(3)
;
	SV *	itile = ST(4)
;
	SV *	iwidth = ST(5)
;
	SV *	iheight = ST(6)
;
	SV *	rawMap = ST(7)
;
	int	RETVAL;
	dXSTARG;
#line 653 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		int start_x = (int) SvUV (istart_x);
		int start_y = (int) SvUV (istart_y);
		int end_x = (int) SvUV (iend_x);
		int end_y = (int) SvUV (iend_y);
		int tile = (int) SvUV (itile);
		int width = (int) SvUV (iwidth);
		int height = (int) SvUV (iheight);

		char * rawMap_data = (char *) SvPVbyte_nolen (SvRV (rawMap));

		RETVAL = checkPathFree_inner(start_x, start_y, end_x, end_y, tile, width, height, rawMap_data);

#line 1010 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PathFinding_getSquareEdgesFromCoord); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PathFinding_getSquareEdgesFromCoord)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "i_x, i_y, iradius, iwidth, iheight, solution_array");
    {
	SV *	i_x = ST(0)
;
	SV *	i_y = ST(1)
;
	SV *	iradius = ST(2)
;
	SV *	iwidth = ST(3)
;
	SV *	iheight = ST(4)
;
	SV *	solution_array = ST(5)
;
#line 678 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		int x = (int) SvUV (i_x);
		int y = (int) SvUV (i_y);
		int radius = (int) SvUV (iradius);
		int width = (int) SvUV (iwidth);
		int height = (int) SvUV (iheight);

		int * limits = getSquareEdgesFromCoord_inner(x, y, radius, width, height);

		AV *array;
 		array = (AV *) SvRV (solution_array);
		av_clear (array);
		av_extend (array, 4);

		av_store(array, 0, newSViv(limits[0]));
		av_store(array, 1, newSViv(limits[1]));
		av_store(array, 2, newSViv(limits[2]));
		av_store(array, 3, newSViv(limits[3]));
#line 1054 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_PathFinding_blockDistance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PathFinding_blockDistance)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "istart_x, istart_y, iend_x, iend_y");
    {
	SV *	istart_x = ST(0)
;
	SV *	istart_y = ST(1)
;
	SV *	iend_x = ST(2)
;
	SV *	iend_y = ST(3)
;
	int	RETVAL;
	dXSTARG;
#line 704 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		int start_x = (int) SvUV (istart_x);
		int start_y = (int) SvUV (istart_y);
		int end_x = (int) SvUV (iend_x);
		int end_y = (int) SvUV (iend_y);

		RETVAL = blockDistance_inner(start_x, start_y, end_x, end_y);

#line 1085 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PathFinding_getClientDist); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PathFinding_getClientDist)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "istart_x, istart_y, iend_x, iend_y");
    {
	SV *	istart_x = ST(0)
;
	SV *	istart_y = ST(1)
;
	SV *	iend_x = ST(2)
;
	SV *	iend_y = ST(3)
;
	int	RETVAL;
	dXSTARG;
#line 722 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		int start_x = (int) SvUV (istart_x);
		int start_y = (int) SvUV (istart_y);
		int end_x = (int) SvUV (iend_x);
		int end_y = (int) SvUV (iend_y);

		RETVAL = getClientDist_inner(start_x, start_y, end_x, end_y);

#line 1117 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PathFinding_get_client_easy_solution); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PathFinding_get_client_easy_solution)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "istart_x, istart_y, iend_x, iend_y, solution_array");
    {
	SV *	istart_x = ST(0)
;
	SV *	istart_y = ST(1)
;
	SV *	iend_x = ST(2)
;
	SV *	iend_y = ST(3)
;
	SV *	solution_array = ST(4)
;
	int	RETVAL;
	dXSTARG;
#line 741 "src\\\\auto\\\\XSTools\\\\PathFinding\\\\PathFinding.xs"
		int start_x = (int) SvUV (istart_x);
		int start_y = (int) SvUV (istart_y);
		int end_x = (int) SvUV (iend_x);
		int end_y = (int) SvUV (iend_y);

		int size = blockDistance_inner(start_x, start_y, end_x, end_y);

		AV *array;
 		array = (AV *) SvRV (solution_array);
		av_clear (array);
		av_extend (array, size);

		int stepType;
		int g = 0;
		int i = 0;

		while (1) {
			HV * rh = (HV *)sv_2mortal((SV *)newHV());

			hv_store(rh, "x", 1, newSViv(start_x), 0);
			hv_store(rh, "y", 1, newSViv(start_y), 0);
			hv_store(rh, "g", 1, newSViv(g), 0);

			av_store(array, i, newRV((SV *)rh));
			i++;

			stepType = 0;
			if (start_x < end_x) {
				start_x++;
				stepType++;
			} else if (start_x > end_x) {
				start_x--;
				stepType++;
			}
			if (start_y < end_y) {
				start_y++;
				stepType++;
			} else if (start_y > end_y) {
				start_y--;
				stepType++;
			}

			if (stepType == 1) {
				g += 10;
			} else if (stepType == 2) {
				g += 14;
			} else if (stepType == 0) {
				break;
			}
		}

		RETVAL = 1;

#line 1197 "src\\auto\\XSTools\\PathFinding\\PathFinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_PathFinding); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_PathFinding)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("PathFinding::create", XS_PathFinding_create, file, "");
        (void)newXSproto_portable("PathFinding::_reset", XS_PathFinding__reset, file, "$$$$$$$$$$$$$$$$$$");
        (void)newXSproto_portable("PathFinding::run", XS_PathFinding_run, file, "$$");
        (void)newXSproto_portable("PathFinding::runcount", XS_PathFinding_runcount, file, "$");
        (void)newXSproto_portable("PathFinding::DESTROY", XS_PathFinding_DESTROY, file, "$");
        (void)newXSproto_portable("PathFinding::checkTile", XS_PathFinding_checkTile, file, "$$$$$$");
        (void)newXSproto_portable("PathFinding::checkLOS", XS_PathFinding_checkLOS, file, "$$$$$$$$");
        (void)newXSproto_portable("PathFinding::canAttack", XS_PathFinding_canAttack, file, "$$$$$$$$$$");
        (void)newXSproto_portable("PathFinding::calcRectArea", XS_PathFinding_calcRectArea, file, "$$$$$$$$");
        (void)newXSproto_portable("PathFinding::checkPathFree", XS_PathFinding_checkPathFree, file, "$$$$$$$$");
        (void)newXSproto_portable("PathFinding::getSquareEdgesFromCoord", XS_PathFinding_getSquareEdgesFromCoord, file, "$$$$$$");
        (void)newXSproto_portable("PathFinding::blockDistance", XS_PathFinding_blockDistance, file, "$$$$");
        (void)newXSproto_portable("PathFinding::getClientDist", XS_PathFinding_getClientDist, file, "$$$$");
        (void)newXSproto_portable("PathFinding::get_client_easy_solution", XS_PathFinding_get_client_easy_solution, file, "$$$$$");
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

